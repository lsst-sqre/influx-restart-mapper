#!/usr/bin/env python3
import asyncio
import jinja2
import logging
import os
from dataclasses import asdict, dataclass, field
from datetime import timedelta
from typing import Any, Dict, List, Union

from influxclient import InfluxClient
import aiohttp

# Task template; shared Jinja2 env is fine.
task_template = jinja2.Template(
    """option v = {bucket: "_monitoring", timeRangeStart: -1h, timeRangeStop: now(), windowPeriod: 10000ms}

option task = {name: "{{taskname}}", every: 1m}

from(bucket: "{{app_bucket}}")
    |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
    |> filter(fn: (r) => r["_measurement"] == "kubernetes_pod_container")
    |> drop(
        columns: [
            "_start",
            "_stop",
            "_host",
            "namespace",
            "host",
            "node_name",
            "phase",
            "readiness",
            "state",
        ],
    )
    |> filter(fn: (r) => r["_field"] == "restarts_total")
    |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    |> tail(n: 2)
    |> difference(columns: ["_value"])
    |> yield(name: "mean")
    |> to(bucket: "restarts_", org: "square")
"""
)

# Utility Function
def fupper(inp: str) -> str:
    if not str:
        return ""
    return inp[0].upper() + inp[1:]


# Simple typealiases to represent InfluxDB v2 object fields
# Unless otherwise specified, they can be found at:
#      https://docs.influxdata.com/influxdb/v2.2/api/#operation/GetBuckets
# "self" doesn't work as an object attribute, unsurprisingly.

RetentionRule = Dict[str, Union[int, str]]
"""An InfluxDB v2 RetentionRule.  Valid keys:
* everySeconds: int
* shardGroupDurationSeconds: int
* type: str
"""


BucketLinks = List[Dict[str, str]]
"""Links for a Bucket object.  Valid keys (all str):
* labels
* members
* org
* owners
* self
* write
"""

URILinks = List[Dict[str, str]]
"""Links for a paginated InfluxDB v2 object.  Valid keys:
* self
* next
* prev
"""

# Some dataclasses to represent InfluxDB v2 objects
# Unless otherwise specified, they can be found at:
#      https://docs.influxdata.com/influxdb/v2.2/api/#operation/GetBuckets


@dataclass
class Label:
    """An InfluxDB Label."""

    id: str = ""
    name: str = ""
    orgId: str = ""
    properties: Dict[str, str] = field(default_factory=dict)


@dataclass
class BucketGet:
    """An InfluxDB v2 Bucket, as returned from
    https://docs.influxdata.com/influxdb/v2.2/api/#operation/GetBuckets
    """

    createdAt: str = ""
    description: str = ""
    id: str = ""
    orgID: str = ""
    updatedAt: str = ""
    labels: list[Label] = field(default_factory=list)
    links: list[BucketLinks] = field(default_factory=list)
    name: str = ""
    retentionRules: list[RetentionRule] = field(default_factory=list)
    type: str = "user"


@dataclass
class BucketPost:
    """An InfluxDB v2 Bucket, that you would send to
    https://docs.influxdata.com/influxdb/v2.2/api/#operation/PostBuckets
    """

    description: str = ""
    name: str = ""
    orgID: str = ""
    retentionRules: list[RetentionRule] = field(default_factory=list)


@dataclass
class TaskGet:
    """An InfluxDB v2 Task, as returned from
    https://docs.influxdata.com/influxdb/v2.2/api/#operation/GetTasks
    """

    authorizationID: str = ""
    createdAt: str = ""
    cron: str = ""
    description: str = ""
    every: str = ""
    flux: str = ""
    id: str = ""
    orgID: str = ""
    labels: List[Label] = field(default_factory=list)
    lastRunError: str = ""
    lastRunStatus: str = ""
    latestCompleted: str = ""
    links: list[BucketLinks] = field(default_factory=list)
    name: str = ""
    offset: str = ""
    org: str = ""
    ownerID: str = ""
    status: str = ""
    type: str = ""
    updatedAt: str = ""


@dataclass
class TaskPost:
    """An InfluxDB v2 Task definition you'd send to create the Task."""

    description: str = ""
    flux: str = ""
    org: str = ""
    orgID: str = ""
    status: str = "active"


class RestartMapper(InfluxClient):
    """The logic needed to build alerts and tasks for applications."""

    async def set_org_id(self) -> None:
        """Set the Organization ID, given the Organization name.

        This doesn't actually work, even if you have r/w on orgs--you just
        get an empty list back.
        """
        url = f"{self.api_url}/orgs"
        obj = await self.get(url, use_session_params=False)
        orgs = obj["orgs"]
        for o in orgs:
            if o["name"] == self.org:
                self.org_id = o["id"]
                return
        raise RuntimeError(f"Could not determine orgID for org {self.org}")

    async def list_buckets(self) -> List[BucketGet]:
        """List all buckets."""
        itemtype = "buckets"
        url = f"{self.api_url}/{itemtype}"
        b_list = await self.list_all(url, itemtype)
        buckets = [BucketGet(**x) for x in b_list]
        self.log.debug(f"Buckets -> {[x.name for x in buckets]}")
        if buckets:
            # This is cheesy, but the orgs permissions don't work.
            self.org_id = buckets[0].orgID
        return buckets

    async def find_application_buckets(
        self, buckets: List[BucketGet]
    ) -> List[BucketGet]:
        """Any bucket whose name neither starts nor ends with an underscore is
        taken to be an application bucket.
        """
        app_buckets = [b for b in buckets if b.name[0] != "_" and b.name[-1] != "_"]
        self.log.debug(f"App Buckets -> {[x.name for x in app_buckets]}")
        self.app_names = [x.name for x in app_buckets]
        return app_buckets

    async def construct_restarts_bucket(self) -> None:
        buckets = await self.list_buckets()
        if not buckets:
            return
        await self.find_application_buckets(buckets)
        bnames = [x.name for x in buckets]
        if "restarts_" in bnames:
            return
        self.log.debug(f"Constructing restarts_ bucket")
        url = f"{self.api_url}/buckets"
        rr: List[RetentionRule] = [
            {"everySeconds": 3600, "shardGroupDurationSeconds": 3600, "type": "expire"}
        ]
        bkt = BucketPost(
            description=f"K8s apps restart tracking bucket",
            name="restarts_",
            orgID=self.org_id,
            retentionRules=rr,
        )
        payloads = [asdict(bkt)]
        await self.post(url, payloads)

    async def construct_tasks(self) -> None:
        extant_tasks = await self.list_tasks()
        extant_tnames = [x.name for x in extant_tasks]
        apps_needing_tasks = [
            x for x in self.app_names if f"{fupper(x)} restarts" not in extant_tnames
        ]
        self.log.debug(f"Apps needing tasks -> {apps_needing_tasks}")

        new_tasks = self.build_tasks(apps_needing_tasks)
        payloads = [asdict(x) for x in new_tasks]
        url = f"{self.api_url}/tasks"
        await self.post(url, payloads)

    def build_tasks(self, apps: List[str]) -> List[TaskPost]:
        """Create a list of task objects to post."""
        tasks = []
        for app in apps:
            input_bkt = app
            taskname = f"{fupper(app)} restarts"
            tgt_bkt = f"{app}_restarts_"
            tasks.append(
                TaskPost(
                    description=taskname,
                    org=self.org,
                    orgID=self.org_id,
                    status="active",
                    flux=task_template.render(taskname=taskname, app_bucket=app),
                )
            )
        return tasks

    async def list_tasks(self) -> List[TaskGet]:
        """List all tasks."""
        itemtype = "tasks"
        url = f"{self.api_url}/{itemtype}"
        pagesize = 100
        obj_list = await self.list_all(url, itemtype, pagesize=pagesize)
        tasks = [TaskGet(**x) for x in obj_list]
        self.log.debug(f"Tasks -> {[x for x in tasks]}")
        return tasks

    async def construct_check(self):
        pass


async def main() -> None:
    async with RestartMapper() as rm:
        await rm.construct_restarts_bucket()
        await rm.construct_tasks()
        await rm.construct_check()


if __name__ == "__main__":
    asyncio.run(main())
