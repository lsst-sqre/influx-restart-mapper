#!/usr/bin/env python3
import asyncio
import jinja2
import logging
import os
from dataclasses import asdict
from datetime import timedelta
from typing import Any, List

from influxclient import InfluxClient
from influxtypes import (BucketGet, BucketPost, TaskGet, TaskPost,
                         CheckPost, DashboardQuery)
import aiohttp

# Task template; shared Jinja2 env is fine.
task_template = jinja2.Template(
    """option v = {bucket: "_monitoring", timeRangeStart: -1h, timeRangeStop: now(), windowPeriod: 10000ms}

option task = {name: "{{taskname}}", every: 1m}

from(bucket: "{{app_bucket}}")
    |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
    |> filter(fn: (r) => r["_measurement"] == "kubernetes_pod_container")
    |> drop(
        columns: [
            "_start",
            "_stop",
            "_host",
            "namespace",
            "host",
            "node_name",
            "phase",
            "readiness",
            "state",
        ],
    )
    |> filter(fn: (r) => r["_field"] == "restarts_total")
    |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    |> tail(n: 2)
    |> difference(columns: ["_value"])
    |> yield(name: "mean")
    |> to(bucket: "restarts_", org: "square")
"""
)

check_text = """import "influxdata/influxdb/monitor"
import "influxdata/influxdb/v1"

data =
    from(bucket: "restarts_")
        |> range(start: -1m)
        |> filter(fn: (r) => r["_measurement"] == "kubernetes_pod_container")
        |> filter(fn: (r) => r["_field"] == "restarts_total")
        |> aggregateWindow(every: 1m, fn: last, createEmpty: false)

crit = (r) => r["restarts_total"] != 0.0
messageFn = (r) => "Check: ${r._check_name}: ${r._value} restarts for ${r.cluster}/${r.container_name}/${r.pod_name}"

data |> v1["fieldsAsCols"]() |> monitor["check"](data: check, messageFn: messageFn, crit: crit)
"""

# Utility Function
def fupper(inp: str) -> str:
    if not str:
        return ""
    return inp[0].upper() + inp[1:]




class RestartMapper(InfluxClient):
    """The logic needed to build alerts and tasks for applications."""

    async def set_org_id(self) -> None:
        """Set the Organization ID, given the Organization name.

        This doesn't actually work, even if you have r/w on orgs--you just
        get an empty list back.
        """
        url = f"{self.api_url}/orgs"
        obj = await self.get(url, use_session_params=False)
        orgs = obj["orgs"]
        for o in orgs:
            if o["name"] == self.org:
                self.org_id = o["id"]
                return
        raise RuntimeError(f"Could not determine orgID for org {self.org}")

    async def list_buckets(self) -> List[BucketGet]:
        """List all buckets."""
        itemtype = "buckets"
        url = f"{self.api_url}/{itemtype}"
        b_list = await self.list_all(url, itemtype)
        buckets = [BucketGet(**x) for x in b_list]
        self.log.debug(f"Buckets -> {[x.name for x in buckets]}")
        if buckets:
            # This is cheesy, but the orgs permissions don't work.
            self.org_id = buckets[0].orgID
        return buckets

    async def find_application_buckets(
        self, buckets: List[BucketGet]
    ) -> List[BucketGet]:
        """Any bucket whose name neither starts nor ends with an underscore is
        taken to be an application bucket.
        """
        app_buckets = [b for b in buckets if b.name[0] != "_" and b.name[-1] != "_"]
        self.log.debug(f"App Buckets -> {[x.name for x in app_buckets]}")
        self.app_names = [x.name for x in app_buckets]
        return app_buckets

    async def construct_restarts_bucket(self) -> None:
        buckets = await self.list_buckets()
        if not buckets:
            return
        await self.find_application_buckets(buckets)
        bnames = [x.name for x in buckets]
        if "restarts_" in bnames:
            return
        self.log.debug(f"Constructing restarts_ bucket")
        url = f"{self.api_url}/buckets"
        rr: List[RetentionRule] = [
            {"everySeconds": 3600, "shardGroupDurationSeconds": 3600, "type": "expire"}
        ]
        bkt = BucketPost(
            description=f"K8s apps restart tracking bucket",
            name="restarts_",
            orgID=self.org_id,
            retentionRules=rr,
        )
        payloads = [asdict(bkt)]
        await self.post(url, payloads)

    async def construct_tasks(self) -> None:
        extant_tasks = await self.list_tasks()
        extant_tnames = [x.name for x in extant_tasks]
        apps_needing_tasks = [
            x for x in self.app_names if f"{fupper(x)} restarts" not in extant_tnames
        ]
        self.log.debug(f"Apps needing tasks -> {apps_needing_tasks}")

        new_tasks = self.build_tasks(apps_needing_tasks)
        payloads = [asdict(x) for x in new_tasks]
        url = f"{self.api_url}/tasks"
        await self.post(url, payloads)

    def build_tasks(self, apps: List[str]) -> List[TaskPost]:
        """Create a list of task objects to post."""
        tasks = []
        for app in apps:
            input_bkt = app
            taskname = f"{fupper(app)} restarts"
            tgt_bkt = f"{app}_restarts_"
            tasks.append(
                TaskPost(
                    description=taskname,
                    org=self.org,
                    orgID=self.org_id,
                    status="active",
                    flux=task_template.render(taskname=taskname, app_bucket=app),
                )
            )
        return tasks

    async def list_tasks(self) -> List[TaskGet]:
        """List all tasks."""
        itemtype = "tasks"
        url = f"{self.api_url}/{itemtype}"
        pagesize = 100
        obj_list = await self.list_all(url, itemtype, pagesize=pagesize)
        tasks = [TaskGet(**x) for x in obj_list]
        self.log.debug(f"Tasks -> {[x for x in tasks]}")
        return tasks

    async def construct_check(self) -> List[Any]:
        self.check_id = ""
        cname = "K8s app restarts TEST"
        itemtype = "checks"
        url = f"{self.api_url}/{itemtype}"
        obj_list = await self.list_all_with_offset(url, itemtype)
        self.log.debug(f"Checks -> {obj_list}")
        for c in obj_list:
            if c["name"] == cname:
                self.check_id = c["id"]
                break
        if not self.check_id:
            cc = await self.create_check(cname)
            payloads = [ asdict(cc) ]
            await self.post(url,payloads)
            # gives a 400 Bad Request right now.

    async def create_check(self, cname):
        dq = DashboardQuery(
            name = cname,
            text = check_text)
        ck = CheckPost(
            description=cname,
            every="1m",
            orgID=self.org_id,
            query=dq,
        )
        return ck



async def main() -> None:
    async with RestartMapper() as rm:
        await rm.construct_restarts_bucket()
        await rm.construct_tasks()
        await rm.construct_check()


if __name__ == "__main__":
    asyncio.run(main())
