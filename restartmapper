#!/usr/bin/env python3
import asyncio
import logging
import os
from dataclasses import asdict, dataclass, field
from datetime import timedelta
from typing import Any, Dict, List, Union

import aiohttp

# InfluxDB2 defaults

DEFAULT_ORG = "default"
DEFAULT_URL = "http://localhost:8086"

# Simple typealiases to represent InfluxDB v2 object fields
# Unless otherwise specified, they can be found at:
#      https://docs.influxdata.com/influxdb/v2.2/api/#operation/GetBuckets
# "self" doesn't work as an object attribute, unsurprisingly.

RetentionRule = Dict[str, Union[int, str]]
"""An InfluxDB v2 RetentionRule.  Valid keys:
* everySeconds: int
* shardGroupDurationSeconds: int
* type: str
"""


BucketLinks = List[Dict[str, str]]
"""Links for a Bucket object.  Valid keys (all str):
* labels
* members
* org
* owners
* self
* write
"""

URILinks = List[Dict[str, str]]
"""Links for a paginated InfluxDB v2 object.  Valid keys:
* self
* next
* prev
"""

# Some dataclasses to represent InfluxDB v2 objects
# Unless otherwise specified, they can be found at:
#      https://docs.influxdata.com/influxdb/v2.2/api/#operation/GetBuckets


@dataclass
class Label:
    """An InfluxDB Label."""

    id: str = ""
    name: str = ""
    orgId: str = ""
    properties: Dict[str, str] = field(default_factory=dict)


@dataclass
class BucketGet:
    """An InfluxDB v2 Bucket, as returned from
    https://docs.influxdata.com/influxdb/v2.2/api/#operation/GetBuckets
    """

    createdAt: str = ""
    description: str = ""
    id: str = ""
    orgID: str = ""
    updatedAt: str = ""
    labels: list[Label] = field(default_factory=list)
    links: list[BucketLinks] = field(default_factory=list)
    name: str = ""
    retentionRules: list[RetentionRule] = field(default_factory=list)
    type: str = "user"

class BucketPost:
    """An InfluxDB v2 Bucket, that you would send to
    https://docs.influxdata.com/influxdb/v2.2/api/#operation/PostBuckets
    """

    description: str = ""
    name: str = ""
    orgID: str = ""
    retentionRules: list[RetentionRule] = field(default_factory=list)
    rp: str = ""
    

@dataclass


class RestartMapper:
    """It wants the same InfluxDBv2 environment variables as InfluxDBv2 or
    Chronograf:
    * INFLUXDB_TOKEN
    * INFLUXDB_URL
    * INFLUXDB_ORG

    """

    def __init__(
        self,
        token: str = os.getenv("INFLUXDB_TOKEN") or "",
        url: str = os.getenv("INFLUXDB_URL") or DEFAULT_URL,
        org: str = os.getenv("INFLUXDB_ORG") or DEFAULT_ORG,
        debug: bool = bool(os.getenv("DEBUG")) or False,
    ) -> None:
        assert token, "INFLUXDB_TOKEN or token param must be set"
        loglevel = logging.WARNING
        self.debug = debug
        if self.debug:
            loglevel = logging.DEBUG
        logging.basicConfig(
            format="%(asctime)s %(levelname)s:%(message)s", level=loglevel
        )
        self.log = logging.getLogger(__name__)
        self.log.debug("Logging established.")
        self.org = org
        self.api_url = url + "/api/v2"
        self.params = {"org": self.org}
        self.session = aiohttp.ClientSession()
        self.session.headers.update({"Authorization": f"Token {token}"})

    async def __aenter__(self):
        return self

    async def __aexit__(self, *excinfo):
        if self.session:
            await self.session.close()

    async def list_buckets(self) -> List[BucketGet]:
        """List all buckets."""
        url = f"{self.api_url}/buckets"
        b_list = []
        pagesize = 20
        # I have no idea why pagesize X really gives you X-2 buckets back,
        # but it does.
        #
        # It also doesn't set links.next.  So rather than trying to
        # chase links, we'll just keep asking, setting "after" to the last
        # bucket we saw, until no more buckets appear.
        params: Dict[str, Any] = {"limit": pagesize}
        params.update(self.params)
        last_id = ""
        while True:
            if last_id:
                params.update({"after": last_id})
            resp = await self.session.get(url, params=params)
            obj = await resp.json()
            bucketlist = obj["buckets"]
            if not bucketlist:
                break
            b_list.extend(bucketlist)
            last_id = bucketlist[-1]["id"]
        buckets = [BucketGet(**x) for x in b_list]
        self.log.debug(f"Buckets -> {[x.name for x in buckets]}")
        return buckets

    async def find_application_buckets(self,
        buckets: List[BucketGet]) -> List[BucketGet]:
        """Any bucket whose name neither starts nor ends with an underscore is
        taken to be an application bucket.
        """
        app_buckets = [ b for b in buckets if b.name[0] != "_" and
                        b.name[-1] != "_" ]
        self.log.debug(f"App Buckets -> {[x.name for x in app_buckets]}")
        return app_buckets

    async def find_restart_buckets(self,
        buckets: List[BucketGet]) -> List[BucketGet]:
        """Any bucket whose name ends with "_restarts_" is taken to be a
        restart-tracking bucket.
        """
        restart_buckets = [ b for b in buckets if
                            b.name.endswith("_restarts_") ]
        self.log.debug("Extant Restart Buckets " +
                       f"-> {[x.name for x in restart_buckets]}")
        return restart_buckets

    async def construct_restart_buckets(self,
                                        apps: List[BucketGet],
                                        extant: List[BucketGet])->None:
        appnames = [x.name for x in apps]
        extantnames = [x.name for x in extant]
        newnames = [f"{n}_restarts_" for n in appnames
                    if f"{n}_restarts_" not in extantnames]
        self.log.debug(f"Buckets to be constructed: {newnames}")
        tasks = []
        for b in newnames:
            task = self.create_bucket(b)
            tasks.append(task)
        await responses = asyncio.gather(*tasks)

    async def create_bucket(self, name: str) -> asyncio.Task:
        url = f"{self.api_url}/buckets"
        
    

async def main() -> None:
    async with RestartMapper() as rm:
        buckets = await rm.list_buckets()
        app_buckets = await rm.find_application_buckets(buckets)
        extant_restart_buckets = await rm.find_restart_buckets(buckets)
        await rm.construct_restart_buckets(app_buckets, extant_restart_buckets)


if __name__ == "__main__":
    asyncio.run(main())
